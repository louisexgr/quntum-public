<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bloch Sphere Visualizer</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <style>
        body {
            font-family: 'Arial', sans-serif;
            margin: 0;
            padding: 100px;
            background-color: #f8f9fa;
            color: #333;
            line-height: 1.6;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 30px;
        }
        
        h1 {
            color: #2c3e50;
            grid-column: 1 / -1;
            border-bottom: 2px solid #0a3049;
            padding-bottom: 10px;
        }
        
        .description {
            grid-column: 1 / -1;
            margin-bottom: 20px;
        }
        
        .controls-panel {
            background-color: white;
            border-radius: 10px;
            padding: 20px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        }
        
        .bloch-container {
            background-color: white;
            border-radius: 10px;
            padding: 20px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            height: 500px;
        }
        
        #bloch-sphere {
            width: 100%;
            height: 100%;
        }
        
        .control-group {
            margin-bottom: 20px;
        }
        
        h2 {
            color: #103650;
            margin-top: 0;
            font-size: 1.4em;
        }
        
        .preset-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 10px;
            margin-top: 15px;
        }
        
        button {
            padding: 10px;
            background-color: #3498db;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            transition: background-color 0.3s;
            font-size: 1em;
        }
        
        button:hover {
            background-color: #2980b9;
        }
        
        .coordinates {
            background-color: #f1f8fe;
            padding: 15px;
            border-radius: 5px;
            margin-top: 20px;
            font-family: monospace;
        }
        
        .quantum-state {
            background-color: #f1f8fe;
            padding: 15px;
            border-radius: 5px;
            margin-top: 20px;
        }
        
        .state-formula {
            font-size: 1.1em;
            margin: 10px 0;
        }
        
        label {
            display: block;
            margin-bottom: 8px;
            font-weight: bold;
        }
        
        input[type="range"] {
            width: 100%;
            margin-bottom: 10px;
        }
        
        .value-display {
            font-family: monospace;
            color: #2c3e50;
        }
        
        @media (max-width: 768px) {
            .container {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Bloch Sphere Visualizer</h1>
        
        <div class="description">
            <p>The Bloch sphere is a geometrical representation of the state space of a qubit. Manipulate the controls to see how different quantum states are represented.</p>
        </div>
        
        <div class="controls-panel">
            <h2>Controls</h2>
            
            <div class="control-group">
                <h3>Preset States</h3>
                <div class="preset-grid">
                    <button onclick="setState(0, 0)">|0⟩</button>
                    <button onclick="setState(Math.PI, 0)">|1⟩</button>
                    <button onclick="setState(Math.PI/2, 0)">|+⟩</button>
                    <button onclick="setState(Math.PI/2, Math.PI)">|-⟩</button>
                    <button onclick="setState(Math.PI/2, Math.PI/2)">|+i⟩</button>
                    <button onclick="setState(Math.PI/2, 3*Math.PI/2)">|-i⟩</button>
                </div>
            </div>
            
            <div class="control-group">
                <label for="theta">Theta (θ): <span class="value-display" id="theta-value">0.00</span>π</label>
                <input type="range" id="theta" min="0" max="3.1416" step="0.01" value="0" oninput="updateBlochSphere()">
                
                <label for="phi">Phi (φ): <span class="value-display" id="phi-value">0.00</span>π</label>
                <input type="range" id="phi" min="0" max="6.2832" step="0.01" value="0" oninput="updateBlochSphere()">
            </div>
            
            <div class="coordinates">
                <h3>Cartesian Coordinates</h3>
                <p>x: <span id="x-value">0.0000</span>, y: <span id="y-value">0.0000</span>, z: <span id="z-value">1.0000</span></p>
                
                <h3>Spherical Coordinates</h3>
                <p>θ: <span id="theta-display">0.00</span>π, φ: <span id="phi-display">0.00</span>π</p>
            </div>
            
            <div class="quantum-state">
                <h3>Quantum State</h3>
                <div class="state-formula" id="state-formula-1">
                    \[ |\psi\rangle = \cos(\theta/2) |0\rangle + e^{i\phi}\sin(\theta/2) |1\rangle \]
                </div>
                <div class="state-formula" id="state-formula-2">
                    \[ |\psi\rangle = 1.0000 |0\rangle + 0.0000 |1\rangle \]
                </div>
            </div>
        </div>
        
        <div class="bloch-container">
            <h2>Bloch Sphere Visualization</h2>
            <div id="bloch-sphere"></div>
        </div>
    </div>

    <script>
        // Three.js variables
        let scene, camera, renderer, sphere, arrow, theta = 0, phi = 0;
        
        // Initialize the Bloch sphere
        function initBlochSphere() {
            // Scene setup
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0xf8f9fa);
            
            // Camera setup
            const container = document.getElementById('bloch-sphere');
            camera = new THREE.PerspectiveCamera(75, container.clientWidth / container.clientHeight, 0.1, 1000);
            camera.position.z = 2.5;
            
            // Renderer setup
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(container.clientWidth, container.clientHeight);
            container.appendChild(renderer.domElement);
            
            // Add axes helper (with thicker lines)
            const axesHelper = new THREE.AxesHelper(1.5);
            const axesMaterial = new THREE.LineBasicMaterial({ linewidth: 2 });
            axesHelper.material = axesMaterial;
            scene.add(axesHelper);
            
            // Create sphere (wireframe with better visibility)
            const geometry = new THREE.SphereGeometry(1, 32, 32);
            const material = new THREE.MeshBasicMaterial({ 
                color: 0x3498db, 
                wireframe: true,
                wireframeLinewidth: 2,
                transparent: true,
                opacity: 0.7
            });
            sphere = new THREE.Mesh(geometry, material);
            scene.add(sphere);
            
            // Create arrow (quantum state) with better visibility
            const dir = new THREE.Vector3(0, 0, 1);
            dir.normalize();
            const origin = new THREE.Vector3(0, 0, 0);
            const length = 1.5;
            const hex = 0xff0000;
            const arrowHelper = new THREE.ArrowHelper(
                dir, 
                origin, 
                length, 
                hex, 
                0.3,  // head length
                0.15  // head width
            );
            arrow = arrowHelper;
            scene.add(arrowHelper);
            
            // Add labels with better visibility
            addLabels();
            
            // Handle window resize
            window.addEventListener('resize', onWindowResize);
            
            // Initial render
            updateBlochSphere();
        }
        
        // Add labels to the Bloch sphere with improved styling
        function addLabels() {
            const labelPositions = [
                { text: "|0⟩", position: new THREE.Vector3(0, 0, 1.3), color: 0x000000 },
                { text: "|1⟩", position: new THREE.Vector3(0, 0, -1.3), color: 0x000000 },
                { text: "|+⟩", position: new THREE.Vector3(1.3, 0, 0), color: 0x000000 },
                { text: "|-⟩", position: new THREE.Vector3(-1.3, 0, 0), color: 0x000000 },
                { text: "|+i⟩", position: new THREE.Vector3(0, 1.3, 0), color: 0x000000 },
                { text: "|-i⟩", position: new THREE.Vector3(0, -1.3, 0), color: 0x000000 }
            ];
            
            labelPositions.forEach(label => {
                const canvas = document.createElement('canvas');
                canvas.width = 256;
                canvas.height = 128;
                const context = canvas.getContext('2d');
                
                context.font = 'Bold 48px Arial';
                context.fillStyle = 'rgba(0, 0, 0, 0.9)';
                context.textAlign = 'center';
                context.textBaseline = 'middle';
                context.fillText(label.text, canvas.width/2, canvas.height/2);
                
                const texture = new THREE.CanvasTexture(canvas);
                const material = new THREE.SpriteMaterial({ 
                    map: texture,
                    transparent: true
                });
                const sprite = new THREE.Sprite(material);
                sprite.position.copy(label.position);
                sprite.scale.set(0.3, 0.15, 1);
                scene.add(sprite);
            });
        }
        
        // Update the Bloch sphere based on theta and phi values
        function updateBlochSphere() {
            // Get values from sliders
            theta = parseFloat(document.getElementById('theta').value);
            phi = parseFloat(document.getElementById('phi').value);
            
            // Update display values
            document.getElementById('theta-value').textContent = (theta / Math.PI).toFixed(2);
            document.getElementById('phi-value').textContent = (phi / Math.PI).toFixed(2);
            document.getElementById('theta-display').textContent = (theta / Math.PI).toFixed(2);
            document.getElementById('phi-display').textContent = (phi / Math.PI).toFixed(2);
            
            // Calculate cartesian coordinates
            const x = Math.sin(theta) * Math.cos(phi);
            const y = Math.sin(theta) * Math.sin(phi);
            const z = Math.cos(theta);
            
            // Update cartesian coordinates display
            document.getElementById('x-value').textContent = x.toFixed(4);
            document.getElementById('y-value').textContent = y.toFixed(4);
            document.getElementById('z-value').textContent = z.toFixed(4);
            
            // Update arrow
            scene.remove(arrow);
            const dir = new THREE.Vector3(x, y, z);
            dir.normalize();
            const origin = new THREE.Vector3(0, 0, 0);
            const length = 1.5;
            const hex = 0xff0000;
            const arrowHelper = new THREE.ArrowHelper(
                dir, 
                origin, 
                length, 
                hex, 
                0.3,  // head length
                0.15  // head width
            );
            arrow = arrowHelper;
            scene.add(arrowHelper);
            
            // Update quantum state formula
            updateQuantumStateFormula(theta, phi);
            
            // Render
            renderer.render(scene, camera);
        }
        
        // Set state to preset values
        function setState(newTheta, newPhi) {
            document.getElementById('theta').value = newTheta;
            document.getElementById('phi').value = newPhi;
            updateBlochSphere();
        }
        
        // Update the quantum state formula display
        function updateQuantumStateFormula(theta, phi) {
            const cosThetaHalf = Math.cos(theta/2);
            const sinThetaHalf = Math.sin(theta/2);
            
            // Update the second formula with actual values
            document.getElementById('state-formula-2').innerHTML = `
                \\[ |\\psi\\rangle = ${cosThetaHalf.toFixed(4)} |0\\rangle + ${sinThetaHalf.toFixed(4)} e^{i${phi.toFixed(2)}} |1\\rangle \\]
            `;
            
            // Re-render MathJax
            if (typeof MathJax !== 'undefined') {
                MathJax.typeset();
            }
        }
        
        // Handle window resize
        function onWindowResize() {
            const container = document.getElementById('bloch-sphere');
            camera.aspect = container.clientWidth / container.clientHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(container.clientWidth, container.clientHeight);
            renderer.render(scene, camera);
        }
        
        // Animation loop
        function animate() {
            requestAnimationFrame(animate);
            renderer.render(scene, camera);
        }
        
        // Initialize when page loads
        window.onload = function() {
            initBlochSphere();
            animate();
        };
    </script>
</body>
</html>